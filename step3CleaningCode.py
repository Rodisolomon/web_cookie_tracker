import os.path
import json
def my_obj_pairs_hook(lst):
    result={}
    count={}
    for key,val in lst:
        if key in count:count[key]=1+count[key]
        else:count[key]=1
        if key in result:
            if count[key] > 2:
                result[key].append(val)
            else:
                result[key]=[result[key], val]
        else:
            result[key]=val
    return result


data = json.load(open("/Users/helen/Desktop/comp_security/ass6/ai.json"), object_pairs_hook=my_obj_pairs_hook)
#print(json.dumps(data, indent=2))

# delete all data in first two webpages and before that
for i in range(len(data)):
    try:
        if data[i]["_source"]["layers"]["tcp"]["tcp.flags"] == "0x0010": #delete ACK
            del data[i]
    except:
        continue

def keys_exists(element, *keys):
    '''
    Check if *keys (nested) exists in `element` (dict).
    '''
    if not isinstance(element, dict):
        raise AttributeError('keys_exists() expects dict as first argument.')
    if len(keys) == 0:
        raise AttributeError('keys_exists() expects at least two arguments, one given.')

    _element = element
    for key in keys:
        try:
            #print(key)
            if type(_element) is list:
                _element = _element[0]
            #print(_element[key])
            #print(key)
            # if type(_element[key]) is str:
            #     print(key)
            #     return False
            #print(_element[key])
            _element = _element[key]

        except KeyError:
            return False
    return True


def retransmission_helper(data): #if retransmission
    try:
        transmission = data["_source"]["layers"]["tcp"]["tcp.analysis"]["tcp.analysis.flags"]["_ws.expert"]["tcp.analysis.retransmission"]
        print("tcp flag")
        return True
    except:
        return False  


#preprocessing, Separate data into a sequence of json file, determined by existence of message [FIN, ACK] and a "Client hello" message after it
fin = 0
f_index = 1
last_idx = 0
lst = []
for i in range(len(data)):
    if (keys_exists(data[i],"_source", "layers", "tcp", "tcp.flags") 
    and data[i]["_source"]["layers"]["tcp"]["tcp.flags"] == "0x0011" #FIN, ACK
    and data[i]["_source"]["layers"]["ip"]["ip.src_host"] == "128.135.11.239" #from website
    and not retransmission_helper(data[i])):
        print(data[i]["_source"]["layers"]["frame"]["frame.time_relative"]) #outputing only message with [FIN, ACK]
        #print("a fin flag")
        fin += 1
        lst.append(data[i])

    try:
        handshake_type = data[i]["_source"]["layers"]["tls"]["tls.record"]["tls.handshake"]["tls.handshake.type"]
        #print("wow a handshake")
        if handshake_type == "1" and fin > 0:
            f_name_n = str(f_index) + "_original.json"  #finish writing the previous file
            open(f_name_n, "w").write( #keep the only useful data, [FIN, ACK] with relative sequence number
            json.dumps(lst, indent=4, separators=(',', ': '))
            )
            print(f_index)
            f_index += 1
            last_idx = i
            fin = 0
            lst = []
    except:
        continue

#print(f_index)
def Sum(file_name): #get sum of relative sequence number in [ACK, FIN]
    f = open(file_name)
    data = json.load(f)
    ret = 0
    for i in range(len(data)):
        try:
            ret += int(int(data[i]["_source"]["layers"]["tcp"]["tcp.seq"]))
        except:
            continue
    return ret

import os



#This is for step 4, but use function in step 3
#similar preprocessing of the captured data generated by me, start from a single file, separate, and stored into a new directory
def candidate_processing(file_name): 
    data = json.load(open(file_name), object_pairs_hook=my_obj_pairs_hook)
    path = os.path.join(os.getcwd(), "z") ####################change
    os.mkdir(path)
    os.rename(os.getcwd() + "/" + file_name, path + "/" + file_name)
    os.chdir(path)
    fin = 0
    f_index = 0
    lst = []
    for i in range(len(data)):
        if (keys_exists(data[i],"_source", "layers", "tcp", "tcp.flags") 
        and data[i]["_source"]["layers"]["tcp"]["tcp.flags"] == "0x0011" #FIN, ACK
        and data[i]["_source"]["layers"]["ip"]["ip.src_host"] == "128.135.11.239" #from website
        and not retransmission_helper(data[i])):
            print(data[i]["_source"]["layers"]["frame"]["frame.time_relative"])
            #print("a fin flag")
            fin += 1
            lst.append(data[i])
        try:
            handshake_type = data[i]["_source"]["layers"]["tls"]["tls.record"]["tls.handshake"]["tls.handshake.type"]
            #print("wow a handshake")
            if handshake_type == "1" and fin > 0:
                f_name_n = str(f_index) + "_original.json"
                open(f_name_n, "w").write( #keep the only useful data, [FIN, ACK] with relative sequence number
                json.dumps(lst, indent=4, separators=(',', ': '))
                ) #finish writing the previous file
                print(f_index)
                f_index += 1
                fin = 0
                lst = []
        except:
            continue
    f_name_n = str(f_index) + "_original.json"
    open(f_name_n, "w").write( #keep the only useful data, [FIN, ACK] with relative sequence number
    json.dumps(lst, indent=4, separators=(',', ': '))
    ) #finish writing the last file with no client

# s = Sum("1_original.json")
# print(f"sum is {s}")
candidate_processing("candidates_.json") #driver code